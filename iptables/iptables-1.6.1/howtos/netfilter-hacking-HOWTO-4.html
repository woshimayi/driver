<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.72">
 <TITLE>Linux netfilter Hacking HOWTO: Information for Programmers</TITLE>
 <LINK HREF="netfilter-hacking-HOWTO-5.html" REL=next>
 <LINK HREF="netfilter-hacking-HOWTO-3.html" REL=previous>
 <LINK HREF="netfilter-hacking-HOWTO.html#toc4" REL=contents>
</HEAD>
<BODY>
<A HREF="netfilter-hacking-HOWTO-5.html">Next</A>
<A HREF="netfilter-hacking-HOWTO-3.html">Previous</A>
<A HREF="netfilter-hacking-HOWTO.html#toc4">Contents</A>
<HR>
<H2><A NAME="s4">4.</A> <A HREF="netfilter-hacking-HOWTO.html#toc4">Information for Programmers</A></H2>

<P>I'll let you in on a secret: my pet hamster did all the coding.  I
was just a channel, a `front' if you will, in my pet's grand plan.
So, don't blame me if there are bugs.  Blame the cute, furry one.</P>

<H2><A NAME="ss4.1">4.1</A> <A HREF="netfilter-hacking-HOWTO.html#toc4.1">Understanding ip_tables</A>
</H2>

<P>iptables simply provides a named array of rules in memory (hence
the name `iptables'), and such information as where packets from each
hook should begin traversal.  After a table is registered, userspace
can read and replace its contents using getsockopt() and setsockopt().</P>

<P>iptables does not register with any netfilter hooks: it relies on
other modules to do that and feed it the packets as appropriate; a
module must register the netfilter hooks and ip_tables separately, and
provide the mechanism to call ip_tables when the hook is reached.</P>

<H3>ip_tables Data Structures</H3>

<P>For convenience, the same data structure is used to represent a
rule by userspace and within the kernel, although a few fields are
only used inside the kernel.</P>

<P>Each rule consists of the following parts:
<OL>
<LI> A `struct ipt_entry'.</LI>
<LI> Zero or more `struct ipt_entry_match' structures, each with a
variable amount (0 or more bytes) of data appended to it.</LI>
<LI> A `struct ipt_entry_target' structure, with a variable amount
(0 or more bytes) of data appended to it.</LI>
</OL>
</P>
<P>The variable nature of the rule gives a huge amount of flexibility for
extensions, as we'll see, especially as each match or target can carry
an arbitrary amount of data.  This does create a few traps, however:
we have to watch out for alignment.  We do this by ensuring that the
`ipt_entry', `ipt_entry_match' and `ipt_entry_target' structures are
conveniently sized, and that all data is rounded up to the maximal
alignment of the machine using the IPT_ALIGN() macro.</P>

<P>The `struct ipt_entry' has the following fields:
<OL>
<LI> A `struct ipt_ip' part, containing the specifications for the
IP header that it is to match.
</LI>
<LI> An `nf_cache' bitfield showing what parts of the packet this
rule examined.
</LI>
<LI> A `target_offset' field indicating the offset from the
beginning of this rule where the ipt_entry_target structure begins.
This should always be aligned correctly (with the IPT_ALIGN macro).
</LI>
<LI> A `next_offset' field indicating the total size of this rule,
including the matches and target.  This should also be aligned
correctly using the IPT_ALIGN macro.
</LI>
<LI> A `comefrom' field used by the kernel to track packet
traversal.
</LI>
<LI> A `struct ipt_counters' field containing the packet and byte
counters for packets which matched this rule.</LI>
</OL>
</P>

<P>The `struct ipt_entry_match' and `struct ipt_entry_target' are very
similar, in that they contain a total (IPT_ALIGN'ed) length field
(`match_size' and `target_size' respectively) and a union holding the
name of the match or target (for userspace), and a pointer (for the
kernel).</P>

<P>Because of the tricky nature of the rule data structure, some helper
routines are provided:</P>
<P>
<DL>
<DT><B>ipt_get_target()</B><DD>
<P>This inline function returns a pointer to
the target of a rule.</P>

<DT><B>IPT_MATCH_ITERATE()</B><DD>
<P>This macro calls the given function for
every match in the given rule.  The function's first argument is the
`struct ipt_match_entry', and other arguments (if any) are those
supplied to the IPT_MATCH_ITERATE() macro. The function must return
either zero for the iteration to continue, or a non-zero value to
stop.</P>

<DT><B>IPT_ENTRY_ITERATE()</B><DD>
<P>This function takes a pointer to an
entry, the total size of the table of entries, and a function to call.
The functions first argument is the `struct ipt_entry', and other
arguments (if any) are those supplied to the IPT_ENTRY_ITERATE()
macro. The function must return either zero for the iteration to
continue, or a non-zero value to stop.</P>
</DL>
</P>

<H3>ip_tables From Userspace</H3>

<P>Userspace has four operations: it can read the current table, read
the info (hook positions and size of table), replace the table (and
grab the old counters), and add in new counters.</P>

<P>This allows any atomic operation to be simulated by userspace: this
is done by the libiptc library, which provides convenience
"add/delete/replace" semantics for programs.</P>

<P>Because these tables are transferred into kernel space, alignment
becomes an issue for machines which have different userspace and
kernelspace type rules (eg. Sparc64 with 32-bit userland).  These
cases are handled by overriding the definition of IPT_ALIGN for these
platforms in `libiptc.h'.</P>

<H3>ip_tables Use And Traversal</H3>

<P>The kernel starts traversing at the location indicated by the
particular hook.  That rule is examined, if the `struct ipt_ip'
elements match, each `struct ipt_entry_match' is checked in turn (the
match function associated with that match is called).  If the match
function returns 0, iteration stops on that rule.  If it sets the
`hotdrop' parameter to 1, the packet will also be immediately dropped
(this is used for some suspicious packets, such as in the tcp match
function).</P>

<P>If the iteration continues to the end, the counters are
incremented, the `struct ipt_entry_target' is examined: if it's a
standard target, the `verdict' field is read (negative means a packet
verdict, positive means an offset to jump to).  If the answer is
positive and the offset is not that of the next rule, the `back'
variable is set, and the previous `back' value is placed in that
rule's `comefrom' field.</P>

<P>For non-standard targets, the target function is called: it returns
a verdict (non-standard targets can't jump, as this would break the
static loop-detection code).  The verdict can be IPT_CONTINUE, to
continue on to the next rule.</P>

<H2><A NAME="ss4.2">4.2</A> <A HREF="netfilter-hacking-HOWTO.html#toc4.2">Extending iptables</A>
</H2>

<P>Because I'm lazy, <CODE>iptables</CODE> is fairly extensible.  This is
basically a scam to palm off work onto other people, which is what
Open Source is all about (cf. Free Software, which as RMS would say,
is about freedom, and I was sitting in one of his talks when I wrote
this).</P>

<P>Extending <CODE>iptables</CODE> potentially involves two parts:
extending the kernel, by writing a new module, and possibly extending
the userspace program <CODE>iptables</CODE>, by writing a new shared
library.</P>

<H3>The Kernel</H3>

<P>Writing a kernel module itself is fairly simple, as you can see
from the examples.  One thing to be aware of is that your code must be
re-entrant: there can be one packet coming in from userspace, while
another arrives on an interrupt.  In fact in SMP there can be one
packet on an interrupt per CPU in 2.3.4 and above.</P>

<P>The functions you need to know about are:</P>
<P>
<DL>
<DT><B>init_module()</B><DD>
<P>This is the entry-point of the module.  It
returns a negative error number, or 0 if it successfully registers
itself with netfilter.</P>

<DT><B>cleanup_module()</B><DD>
<P>This is the exit point of the module; it
should unregister itself with netfilter.</P>

<DT><B>ipt_register_match()</B><DD>
<P>This is used to register a new match
type.  You hand it a `struct ipt_match', which is usually declared as
a static (file-scope) variable.</P>

<DT><B>ipt_register_target()</B><DD>
<P>This is used to register a new
type.  You hand it a `struct ipt_target', which is usually declared as
a static (file-scope) variable.</P>

<DT><B>ipt_unregister_target()</B><DD>
<P>Used to unregister your target.</P>

<DT><B>ipt_unregister_match()</B><DD>
<P>Used to unregister your match.</P>
</DL>
</P>

<P>One warning about doing tricky things (such as providing counters)
in the extra space in your new match or target.  On SMP machines, the
entire table is duplicated using memcpy for each CPU: if you really
want to keep central information, you should see the method used in
the `limit' match.</P>

<H3>New Match Functions</H3>

<P>New match functions are usually written as a standalone module.
It's possible to have these modules extensible in turn, although it's
usually not necessary.  One way would be to use the netfilter
framework's `nf_register_sockopt' function to allows users to talk to
your module directly.  Another way would be to export symbols for
other modules to register themselves, the same way netfilter and
ip_tables do.</P>

<P>The core of your new match function is the struct ipt_match which
it passes to `ipt_register_match()'.  This structure has the following
fields:</P>
<P>
<DL>
<DT><B>list</B><DD>
<P>This field is set to any junk, say `{ NULL, NULL }'.</P>

<DT><B>name</B><DD>
<P>This field is the name of the match function, as
referred to by userspace.  The name should match the name of the
module (i.e., if the name is "mac", the module must be "ipt_mac.o") for
auto-loading to work.</P>

<DT><B>match</B><DD>
<P>This field is a pointer to a match function, which
takes the skb, the in and out device pointers (one of which may be
NULL, depending on the hook), a pointer to the match data in the rule
that is worked on (the structure that was prepared in userspace), the
IP offset (non-zero means
a non-head fragment), a pointer to the protocol header (i.e., just
past the IP header), the length of the data (ie. the packet length
minus the IP header length) and finally a pointer to a `hotdrop'
variable.  It should return non-zero if the packet matches, and can
set `hotdrop' to 1 if it returns 0, to indicate that the packet must
be dropped immediately.</P>

<DT><B>checkentry</B><DD>
<P>This field is a pointer to a function which
checks the specifications for a rule; if this returns 0, then the rule
will not be accepted from the user.  For example, the "tcp" match type
will only accept tcp packets, and so if the `struct ipt_ip' part of
the rule does not specify that the protocol must be tcp, a zero is
returned.  The tablename argument allows your match to control what
tables it can be used in, and the `hook_mask' is a bitmask of hooks
this rule may be called from: if your match does not make sense from
some netfilter hooks, you can avoid that here.</P>

<DT><B>destroy</B><DD>
<P>This field is a pointer to a function which is
called when an entry using this match is deleted.  This allows you to
dynamically allocate resources in checkentry and clean them up here.</P>

<DT><B>me</B><DD>
<P>This field is set to `THIS_MODULE', which gives a
pointer to your module.  It causes the usage-count to go up and down
as rules of that type are created and destroyed.  This prevents a user
removing the module (and hence cleanup_module() being called) if a
rule refers to it.</P>
</DL>
</P>

<H3>New Targets</H3>

<P>If your target alters the packet (ie. the headers or the body), it
must call skb_unshare() to copy the packet in case it is cloned:
otherwise any raw sockets which have a clone of the skbuff will see
the alterations (ie. people will see wierd stuff happening in
tcpdump).</P>

<P>New targets are also usually written as a standalone module.  The
discussions under the above section on `New Match Functions' apply
equally here.</P>

<P>The core of your new target is the struct ipt_target that it
passes to ipt_register_target().  This structure has the following
fields:</P>
<P>
<DL>
<DT><B>list</B><DD>
<P>This field is set to any junk, say `{ NULL, NULL }'.</P>

<DT><B>name</B><DD>
<P>This field is the name of the target function, as
referred to by userspace.  The name should match the name of the
module (i.e., if the name is "REJECT", the module must be
"ipt_REJECT.o") for auto-loading to work.</P>

<DT><B>target</B><DD>
<P>This is a pointer to the target function, which
takes the skbuff, the hook number, the input and output device
pointers (either of which may be NULL), a pointer to the target data,
and the position of the rule in the table. The target function may
return either IPT_CONTINUE (-1) if traversing should continue, or a
netfilter verdict (NF_DROP, NF_ACCEPT, NF_STOLEN etc.).</P>

<DT><B>checkentry</B><DD>
<P>This field is a pointer to a function which
checks the specifications for a rule; if this returns 0, then the
rule will not be accepted from the user.</P>

<DT><B>destroy</B><DD>
<P>This field is a pointer to a function which is
called when an entry using this target is deleted.  This allows you
to dynamically allocate resources in checkentry and clean them up
here.</P>

<DT><B>me</B><DD>
<P>This field is set to `THIS_MODULE', which gives a
pointer to your module.  It causes the usage-count to go up and down
as rules with this as a target are created and destroyed.  This
prevents a user removing the module (and hence cleanup_module() being
called) if a rule refers to it.</P>
</DL>
</P>

<H3>New Tables</H3>

<P>You can create a new table for your specific purpose if you wish.
To do this, you call `ipt_register_table()', with a `struct
ipt_table', which has the following fields:</P>
<P>
<DL>
<DT><B>list</B><DD>
<P>This field is set to any junk, say `{ NULL, NULL }'.</P>

<DT><B>name</B><DD>
<P>This field is the name of the table function, as
referred to by userspace.  The name should match the name of the
module (i.e., if the name is "nat", the module must be
"iptable_nat.o") for auto-loading to work.</P>

<DT><B>table</B><DD>
<P>This is a fully-populated `struct ipt_replace', as
used by userspace to replace a table.  The `counters' pointer should
be set to NULL.  This data structure can be declared `__initdata' so
it is discarded after boot.</P>

<DT><B>valid_hooks</B><DD>
<P>This is a bitmask of the IPv4 netfilter hooks
you will enter the table with: this is used to check that those entry
points are valid, and to calculate the possible hooks for ipt_match
and ipt_target `checkentry()' functions.</P>

<DT><B>lock</B><DD>
<P>This is the read-write spinlock for the entire table;
initialize it to RW_LOCK_UNLOCKED.</P>

<DT><B>private</B><DD>
<P>This is used internally by the ip_tables code.</P>
</DL>
</P>

<H3>Userspace Tool</H3>

<P>Now you've written your nice shiny kernel module, you may want to
control the options on it from userspace.  Rather than have a branched
version of <CODE>iptables</CODE> for each extension, I use the very latest
90's technology: furbies.  Sorry, I mean shared libraries.</P>

<P>New tables generally don't require any extension to
<CODE>iptables</CODE>: the user just uses the `-t' option to make it use
the new table.</P>

<P>The shared library should have an `_init()' function, which will
automatically be called upon loading: the moral equivalent of the
kernel module's `init_module()' function.  This should call
`register_match()' or `register_target()', depending on whether your
shared library provides a new match or a new target.</P>

<P>You need to provide a shared library: this can be used to
initialize part of the structure, or provide additional options.  I
now insist on a shared library even if it doesn't do anything, to
reduce problem reports where the shares libraries are missing.</P>

<P>There are useful functions described in the `iptables.h' header,
especially:
<DL>
<DT><B>check_inverse()</B><DD>
<P>checks if an argument is actually a `!',
and if so, sets the `invert' flag if not already set.  If it returns
true, you should increment optind, as done in the examples.</P>

<DT><B>string_to_number()</B><DD>
<P>converts a string into a number in the
given range, returning -1 if it is malformed or out of range.
`string_to_number' rely on `strtol' (see the manpage), meaning
that a leading "0x" would make the number be in Hexadecimal base, a leading
"0" would make it be in Octal base.</P>

<DT><B>exit_error()</B><DD>
<P>should be called if an error is found.
Usually the first argument is `PARAMETER_PROBLEM', meaning the user
didn't use the command line correctly.</P>
</DL>
</P>

<H3>New Match Functions</H3>

<P>Your shared library's _init() function hands `register_match()' a
pointer to a static `struct iptables_match', which has the following
fields:</P>
<P>
<DL>
<DT><B>next</B><DD>
<P>This pointer is used to make a linked list of matches
(such as used for listing rules).  It should be set to NULL initially.</P>

<DT><B>name</B><DD>
<P>The name of the match function.  This should match the
library name (eg "tcp" for `libipt_tcp.so').</P>

<DT><B>version</B><DD>
<P>Usually set to the IPTABLES_VERSION macro: this is
used to ensure that the <CODE>iptables</CODE> binary doesn't pick up the
wrong shared libraries by mistake.</P>

<DT><B>size</B><DD>
<P>The size of the match data for this match; you should
use the IPT_ALIGN() macro to ensure it is correctly aligned.</P>

<DT><B>userspacesize</B><DD>
<P>For some matches, the kernel changes some
fields internally (the `limit' target is a case of this).  This means
that a simple `memcmp()' is insufficient to compare two rules
(required for delete-matching-rule functionality).  If this is the
case, place all the fields which do not change at the start of the
structure, and put the size of the unchanging fields here.  Usually,
however, this will be identical to the `size' field.</P>

<DT><B>help</B><DD>
<P>A function which prints out the option synopsis.</P>

<DT><B>init</B><DD>
<P>This can be used to initialize the extra space (if
any) in the ipt_entry_match structure, and set any nfcache bits; if
you are examining something not expressible using the contents of
`linux/include/netfilter_ipv4.h', then simply OR in the NFC_UNKNOWN
bit.  It will be called before `parse()'.</P>

<DT><B>parse</B><DD>
<P>This is called when an unrecognized option is seen on
the command line: it should return non-zero if the option was indeed
for your library.  `invert' is true if a `!' has already been seen.
The `flags' pointer is for the exclusive use of your match library,
and is usually used to store a bitmask of options which have been
specified.  Make sure you adjust the nfcache field.  You may extend
the size of the `ipt_entry_match' structure by reallocating if
necessary, but then you must ensure that the size is passed through
the IPT_ALIGN macro.</P>

<DT><B>final_check</B><DD>
<P>This is called after the command line has been
parsed, and is handed the `flags' integer reserved for your library.
This gives you a chance to check that any compulsory options have been
specified, for example: call `exit_error()' if this is the case.</P>

<DT><B>print</B><DD>
<P>This is used by the chain listing code to print (to
standard output) the extra match information (if any) for a rule.  The
numeric flag is set if the user specified the `-n' flag.</P>

<DT><B>save</B><DD>
<P>This is the reverse of parse: it is used by
`iptables-save' to reproduce the options which created the rule.</P>

<DT><B>extra_opts</B><DD>
<P>This is a NULL-terminated list of extra options
which your library offers.  This is merged with the current options
and handed to getopt_long; see the man page for details.  The return
code for getopt_long becomes the first argument (`c') to your
`parse()' function.</P>
</DL>
</P>
<P>There are extra elements at the end of this structure for use
internally by <CODE>iptables</CODE>: you don't need to set them.</P>

<H3>New Targets</H3>

<P>Your shared library's _init() function hands `register_target()' it
a pointer to a static `struct iptables_target', which has similar
fields to the iptables_match structure detailed above.</P>

<H3>Using `libiptc'</H3>

<P><CODE>libiptc</CODE> is the iptables control library, designed for
listing and manipulating rules in the iptables kernel module.  While
its current use is for the iptables program, it makes writing other
tools fairly easy.  You need to be root to use these functions.</P>

<P>The kernel tables themselves are simply a table of rules, and a set
of numbers representing entry points.  Chain names ("INPUT", etc) are
provided as an abstraction by the library.  User defined chains are
labelled by inserting an error node before the head of the
user-defined chain, which contains the chain name in the extra data
section of the target (the builtin chain positions are defined by the
three table entry points).</P>

<P>The following standard targets are supported: ACCEPT, DROP, QUEUE
(which are translated to NF_ACCEPT, NF_DROP, and NF_QUEUE,
respectively), RETURN (which is translated to a special IPT_RETURN
value handled by ip_tables), and JUMP (which is translated from the
chain name to an actual offset within the table).</P>

<P>When `iptc_init()' is called, the table, including the counters, is
read.  This table is manipulated by the `iptc_insert_entry()',
`iptc_replace_entry()', `iptc_append_entry()', `iptc_delete_entry()',
`iptc_delete_num_entry()', `iptc_flush_entries()',
`iptc_zero_entries()', `iptc_create_chain()' `iptc_delete_chain()',
and `iptc_set_policy()' functions.</P>

<P>The table changes are not written back until the `iptc_commit()'
function is called.  This means it is possible for two library users
operating on the same chain to race each other; locking would be
required to prevent this, and it is not currently done.</P>

<P>There is no race with counters, however; counters are added back in
to the kernel in such a way that counter increments between the
reading and writing of the table still show up in the new table.</P>

<P>There are various helper functions:</P>
<P>
<DL>
<DT><B>iptc_first_chain()</B><DD>
<P>This function returns the first chain
name in the table.</P>

<DT><B>iptc_next_chain()</B><DD>
<P>This function returns the next chain name
in the table: NULL means no more chains.</P>

<DT><B>iptc_builtin()</B><DD>
<P>Returns true if the given chain name is the
name of a builtin chain.</P>

<DT><B>iptc_first_rule()</B><DD>
<P>This returns a pointer to the first rule
in the given chain name: NULL for an empty chain.</P>

<DT><B>iptc_next_rule()</B><DD>
<P>This returns a pointer to the next rule in
the chain: NULL means the end of the chain.</P>

<DT><B>iptc_get_target()</B><DD>
<P>This gets the target of the given rule.  If
it's an extended target, the name of that target is returned.  If it's
a jump to another chain, the name of that chain is returned.  If it's
a verdict (eg. DROP), that name is returned.  If it has no target (an
accounting-style rule), then the empty string is returned.</P>

<P>Note that this function should be used instead of using the value
of the `verdict' field of the ipt_entry structure directly, as it
offers the above further interpretations of the standard verdict.</P>

<DT><B>iptc_get_policy()</B><DD>
<P>This gets the policy of a builtin chain,
and fills in the `counters' argument with the hit statistics on that
policy.</P>

<DT><B>iptc_strerror()</B><DD>
<P>This function returns a more meaningful
explanation of a failure code in the iptc library.  If a function
fails, it will always set errno: this value can be passed to
iptc_strerror() to yield an error message.</P>
</DL>
</P>

<H2><A NAME="ss4.3">4.3</A> <A HREF="netfilter-hacking-HOWTO.html#toc4.3">Understanding NAT</A>
</H2>

<P>Welcome to Network Address Translation in the kernel.  Note that
the infrastructure offered is designed more for completeness than raw
efficiency, and that future tweaks may increase the efficiency
markedly.  For the moment I'm happy that it works at all.</P>

<P>NAT is separated into connection tracking (which doesn't manipulate
packets at all), and the NAT code itself.  Connection tracking is also
designed to be used by an iptables modules, so it makes subtle
distinctions in states which NAT doesn't care about.</P>

<H3>Connection Tracking</H3>

<P>Connection tracking hooks into high-priority NF_IP_LOCAL_OUT and
NF_IP_PRE_ROUTING hooks, in order to see packets before they enter the
system.</P>

<P>The nfct field in the skb is a pointer to inside the struct
ip_conntrack, at one of the infos[] array.  Hence we can tell the
state of the skb by which element in this array it is pointing to:
this pointer encodes both the state structure and the relationship of
this skb to that state.</P>

<P>The best way to extract the `nfct' field is to call
`ip_conntrack_get()', which returns NULL if it's not set, or the
connection pointer, and fills in ctinfo which describes the
relationship of the packet to that connection.  This enumerated type
has several values:</P>
<P>
<DL>

<DT><B>IP_CT_ESTABLISHED</B><DD>
<P>The packet is part of an established
connection, in the original direction.</P>

<DT><B>IP_CT_RELATED</B><DD>
<P>The packet is related to the connection, and
is passing in the original direction.</P>

<DT><B>IP_CT_NEW</B><DD>
<P>The packet is trying to create a new connection
(obviously, it is in the original direction).</P>

<DT><B>IP_CT_ESTABLISHED + IP_CT_IS_REPLY</B><DD>
<P>The packet is part of an
established connection, in the reply direction.</P>

<DT><B>IP_CT_RELATED + IP_CT_IS_REPLY</B><DD>
<P>The packet is related to the
connection, and is passing in the reply direction.</P>
</DL>
</P>
<P>Hence a reply packet can be identified by testing for >=
IP_CT_IS_REPLY.</P>

<H2><A NAME="ss4.4">4.4</A> <A HREF="netfilter-hacking-HOWTO.html#toc4.4">Extending Connection Tracking/NAT</A>
</H2>

<P>These frameworks are designed to accommodate any number of protocols
and different mapping types.  Some of these mapping types might be
quite specific, such as a load-balancing/fail-over mapping type.</P>

<P>Internally, connection tracking converts a packet to a "tuple",
representing the interesting parts of the packet, before searching for
bindings or rules which match it.  This tuple has a manipulatable
part, and a non-manipulatable part; called "src" and "dst", as this is
the view for the first packet in the Source NAT world (it'd be a reply
packet in the Destination NAT world).  The tuple for every packet in
the same packet stream in that direction is the same.</P>

<P>For example, a TCP packet's tuple contains the manipulatable part:
source IP and source port, the non-manipulatable part: destination IP
and the destination port.  The manipulatable and non-manipulatable
parts do not need to be the same type though; for example, an ICMP
packet's tuple contains the manipulatable part: source IP and the ICMP
id, and the non-manipulatable part: the destination IP and the ICMP
type and code.</P>

<P>Every tuple has an inverse, which is the tuple of the reply packets
in the stream.  For example, the inverse of an ICMP ping packet, icmp
id 12345, from 192.168.1.1 to 1.2.3.4, is a ping-reply packet, icmp id
12345, from 1.2.3.4 to 192.168.1.1.</P>

<P>These tuples, represented by the `struct ip_conntrack_tuple', are used
widely.  In fact, together with the hook the packet came in on (which
has an effect on the type of manipulation expected), and the device
involved, this is the complete information on the packet.</P>

<P>Most tuples are contained within a `struct
ip_conntrack_tuple_hash', which adds a doubly linked list entry, and a
pointer to the connection that the tuple belongs to.</P>

<P>A connection is represented by the `struct ip_conntrack': it has
two `struct ip_conntrack_tuple_hash' fields: one referring to the
direction of the original packet (tuplehash[IP_CT_DIR_ORIGINAL]), and
one referring to packets in the reply direction
(tuplehash[IP_CT_DIR_REPLY]).</P>

<P>Anyway, the first thing the NAT code does is to see if the
connection tracking code managed to extract a tuple and find an
existing connection, by looking at the skbuff's nfct field; this tells
us if it's an attempt on a new connection, or if not, which direction
it is in; in the latter case, then the manipulations determined
previously for that connection are done.</P>

<P>If it was the start of a new connection, we look for a rule for that
tuple, using the standard iptables traversal mechanism, on the `nat'
table.  If a rule matches, it is used to initialize the manipulations
for both that direction and the reply; the connection-tracking code is
told that the reply it should expect has changed.  Then, it's
manipulated as above.</P>

<P>If there is no rule, a `null' binding is created: this usually does
not map the packet, but exists to ensure we don't map another stream
over an existing one.  Sometimes, the null binding cannot be created,
because we have already mapped an existing stream over it, in which
case the per-protocol manipulation may try to remap it, even though
it's nominally a `null' binding.</P>

<H3>Standard NAT Targets</H3>

<P>NAT targets are like any other iptables target extensions, except
they insist on being used only in the `nat' table.  Both the SNAT and
DNAT targets take a `struct ip_nat_multi_range' as their extra data;
this is used to specify the range of addresses a mapping is allowed to
bind into.  A range element, `struct ip_nat_range' consists of an
inclusive minimum and maximum IP address, and an inclusive maximum and
minimum protocol-specific value (eg. TCP ports).  There is also room
for flags, which say whether the IP address can be mapped (sometimes
we only want to map the protocol-specific part of a tuple, not the
IP), and another to say that the protocol-specific part of the range
is valid.</P>

<P>A multi-range is an array of these `struct ip_nat_range' elements;
this means that a range could be "1.1.1.1-1.1.1.2 ports 50-55 AND
1.1.1.3 port 80".  Each range element adds to the range (a union, for
those who like set theory).</P>

<H3>New Protocols</H3>

<H3>Inside The Kernel</H3>

<P>Implementing a new protocol first means deciding what the
manipulatable and non-manipulatable parts of the tuple should be.
Everything in the tuple has the property that it identifies the stream
uniquely.  The manipulatable part of the tuple is the part you can do
NAT with: for TCP this is the source port, for ICMP it's the icmp ID;
something to use as a "stream identifier".  The non-manipulatable part
is the rest of the packet that uniquely identifies the stream, but we
can't play with (eg. TCP destination port, ICMP type).</P>

<P>Once you've decided this, you can write an extension to the
connection-tracking code in the directory, and go about populating the
`ip_conntrack_protocol' structure which you need to pass to
`ip_conntrack_register_protocol()'.</P>

<P>The fields of `struct ip_conntrack_protocol' are:</P>
<P>
<DL>
<DT><B>list</B><DD>
<P>Set it to '{ NULL, NULL }'; used to sew you into the list.</P>

<DT><B>proto</B><DD>
<P>Your protocol number; see `/etc/protocols'.</P>

<DT><B>name</B><DD>
<P>The name of your protocol.  This is the name the user
will see; it's usually best if it's the canonical name in
`/etc/protocols'.</P>

<DT><B>pkt_to_tuple</B><DD>
<P>The function which fills out the protocol
specific parts of the tuple, given the packet.  The `datah' pointer
points to the start of your header (just past the IP header), and the
datalen is the length of the packet.  If the packet isn't long enough
to contain the header information, return 0; datalen will always be
at least 8 bytes though (enforced by framework).</P>

<DT><B>invert_tuple</B><DD>
<P>This function is simply used to change the
protocol-specific part of the tuple into the way a reply to that
packet would look.</P>

<DT><B>print_tuple</B><DD>
<P>This function is used to print out the
protocol-specific part of a tuple; usually it's sprintf()'d into the
buffer provided.  The number of buffer characters used is returned.
This is used to print the states for the /proc entry.</P>

<DT><B>print_conntrack</B><DD>
<P>This function is used to print the private
part of the conntrack structure, if any, also used for printing the
states in /proc.</P>

<DT><B>packet</B><DD>
<P>This function is called when a packet is seen which
is part of an established connection.  You get a pointer to the
conntrack structure, the IP header, the length, and the ctinfo.  You
return a verdict for the packet (usually NF_ACCEPT), or -1 if the
packet is not a valid part of the connection.  You can delete the
connection inside this function if you wish, but you must use the
following idiom to avoid races (see ip_conntrack_proto_icmp.c):</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
if (del_timer(&amp;ct->timeout))
        ct->timeout.function((unsigned long)ct);
</PRE>
</CODE></BLOCKQUOTE>
</P>

<DT><B>new</B><DD>
<P>This function is called when a packet creates a
connection for the first time; there is no ctinfo arg, since the first
packet is of ctinfo IP_CT_NEW by definition.  It returns 0 to fail to
create the connection, or a connection timeout in jiffies.</P>
</DL>
</P>
<P>Once you've written and tested that you can track your new protocol,
it's time to teach NAT how to translate it.  This means writing a new
module; an extension to the NAT code and go about populating the
`ip_nat_protocol' structure which you need to pass to
`ip_nat_protocol_register()'.</P>
<P>
<DL>
<DT><B>list</B><DD>
<P>Set it to '{ NULL, NULL }'; used to sew you into the list.</P>

<DT><B>name</B><DD>
<P>The name of your protocol.  This is the name the user
will see; it's best if it's the canonical name in `/etc/protocols' for
userspace auto-loading, as we'll see later.</P>

<DT><B>protonum</B><DD>
<P>Your protocol number; see `/etc/protocols'.</P>

<DT><B>manip_pkt</B><DD>
<P>This is the other half of connection tracking's
pkt_to_tuple function: you can think of it as "tuple_to_pkt".  There
are some differences though: you get a pointer to the start of the IP
header, and the total packet length.  This is because some protocols
(UDP, TCP) need to know the IP header.  You're given the
ip_nat_tuple_manip field from the tuple (i.e., the "src" field), rather
than the entire tuple, and the type of manipulation you are to
perform.</P>

<DT><B>in_range</B><DD>
<P>This function is used to tell if manipulatable
part of the given tuple is in the given range.  This function is a bit
tricky: we're given the manipulation type which has been applied to
the tuple, which tells us how to interpret the range (is it a source
range or a destination range we're aiming for?).</P>

<P>This function is used to check if an existing mapping puts us in
the right range, and also to check if no manipulation is necessary at
all.</P>

<DT><B>unique_tuple</B><DD>
<P>This function is the core of NAT: given a
tuple and a range, we're to alter the per-protocol part of the tuple
to place it within the range, and make it unique.  If we can't find an
unused tuple in the range, return 0.  We also get a pointer to the
conntrack structure, which is required for ip_nat_used_tuple().</P>

<P>The usual approach is to simply iterate the per-protocol part of
the tuple through the range, checking `ip_nat_used_tuple()' on it,
until one returns false.</P>

<P>Note that the null-mapping case has already been checked: it's
either outside the range given, or already taken.</P>

<P>If IP_NAT_RANGE_PROTO_SPECIFIED isn't set, it means that the user
is doing NAT, not NAPT: do something sensible with the range.  If no
mapping is desirable (for example, within TCP, a destination mapping
should not change the TCP port unless ordered to), return 0.</P>

<DT><B>print</B><DD>
<P>Given a character buffer, a match tuple and a mask,
write out the per-protocol parts and return the length of the buffer
used.</P>

<DT><B>print_range</B><DD>
<P>Given a character buffer and a range, write out
the per-protocol part of the range, and return the length of the
buffer used.  This won't be called if the IP_NAT_RANGE_PROTO_SPECIFIED
flag wasn't set for the range.</P>
</DL>
</P>

<H3>New NAT Targets</H3>

<P>This is the really interesting part.  You can write new NAT targets
which provide a new mapping type: two extra targets are provided in
the default package: MASQUERADE and REDIRECT.  These are fairly simple
to illustrate the potential and power of writing a new NAT target.</P>

<P>These are written just like any other iptables targets, but
internally they will extract the connection and call
`ip_nat_setup_info()'.</P>

<H3>Protocol Helpers</H3>

<P>Protocol helpers for connection tracking allow the connection
tracking code to understand protocols which use multiple network
connections (eg. FTP) and mark the `child' connections as being
related to the initial connection, usually by reading the related
address out of the data stream.</P>

<P>Protocol helpers for NAT do two things: firstly allow the NAT code
to manipulate the data stream to change the address contained within
it, and secondly to perform NAT on the related connection when it
comes in, based on the original connection.</P>

<H3>Connection Tracking Helper Modules</H3>

<H3>Description</H3>

<P>The duty of a connection tracking module is to specify which packets
belong to an already established connection. The module has the
following means to do that:</P>
<P>
<UL>
<LI>Tell netfilter which packets our module is interested in (most
helpers operate on a particular port).
</LI>
<LI>Register a function with netfilter.  This function is called for
every packet which matches the criteria above.
</LI>
<LI>An `ip_conntrack_expect_related()' function which can be called
from there to tell netfilter to expect related connections.</LI>
</UL>
</P>

<P>If there is some additional work to be done at the time the first packet
of the expected connection arrives, the module can register a callback
function which is called at that time.</P>

<H3>Structures and Functions Available</H3>

<P>Your kernel module's init function has to call
`ip_conntrack_helper_register()' with a pointer to a
`struct ip_conntrack_helper'.  This struct has the following fields:</P>
<P>
<DL>
<DT><B>list</B><DD>
<P>This is the header for the linked list. Netfilter
handles this list internally. Just initialize it with `{ NULL, NULL }'.</P>

<DT><B>name</B><DD>
<P>This is a pointer to a string constant specifying the
name of the protocol. ("ftp", "irc", ...)</P>

<DT><B>flags</B><DD>
<P>A set of flags with one or more out of the following flgs:
<UL>
<LI>IP_CT_HELPER_F_REUSE_EXPECT : Reuse expectations if the limit (see
`max_expected` below) is reached.</LI>
</UL>
</P>

<DT><B>me</B><DD>
<P>A pointer to the module structure of the helper.  Intitialize this with  the `THIS_MODULE' macro.</P>

<DT><B>max_expected</B><DD>
<P>Maximum number of unconfirmed (outstanding) expectations.</P>

<DT><B>timeout</B><DD>
<P>Timeout (in seconds) for each unconfirmed expectation.  An expectation is deleted `timeout' seconds after the expectation was issued with the `ip_conntrack_expect_related()' function.</P>

<DT><B>tuple</B><DD>
<P>This is a `struct ip_conntrack_tuple' which specifies
the packets our conntrack helper module is interested in.</P>

<DT><B>mask</B><DD>
<P>Again a `struct ip_conntrack_tuple'. This mask
specifies which bits of <CODE>tuple</CODE> are valid.</P>

<DT><B>help</B><DD>
<P>The function which netfilter should call for each
packet matching tuple+mask</P>
</DL>
</P>

<H3>Example skeleton of a conntrack helper module</H3>

<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#define FOO_PORT        111

static int foo_expectfn(struct ip_conntrack *new)
{
        /* called when the first packet of an expected
           connection arrives */

        return 0;
}

static int foo_help(const struct iphdr *iph, size_t len,
                struct ip_conntrack *ct,
                enum ip_conntrack_info ctinfo)
{
        /* analyze the data passed on this connection and
           decide how related packets will look like */

        /* update per master-connection private data
           (session state, ...) */
        ct->help.ct_foo_info = ...

        if (there_will_be_new_packets_related_to_this_connection)
        {
                struct ip_conntrack_expect exp;

                memset(&amp;exp, 0, sizeof(exp));
                exp.t = tuple_specifying_related_packets;
                exp.mask = mask_for_above_tuple;
                exp.expectfn = foo_expectfn;
                exp.seq = tcp_sequence_number_of_expectation_cause;

                /* per slave-connection private data */
                exp.help.exp_foo_info = ...

                ip_conntrack_expect_related(ct, &amp;exp);
        }
        return NF_ACCEPT;
}

static struct ip_conntrack_helper foo;

static int __init init(void)
{
        memset(&amp;foo, 0, sizeof(struct ip_conntrack_helper);

        foo.name = "foo";
        foo.flags = IP_CT_HELPER_F_REUSE_EXPECT;
        foo.me = THIS_MODULE;
        foo.max_expected = 1;   /* one expectation at a time */
        foo.timeout = 0;        /* expectation never expires */

        /* we are interested in all TCP packets with destport 111 */
        foo.tuple.dst.protonum = IPPROTO_TCP;
        foo.tuple.dst.u.tcp.port = htons(FOO_PORT);
        foo.mask.dst.protonum = 0xFFFF;
        foo.mask.dst.u.tcp.port = 0xFFFF;
        foo.help = foo_help;

        return ip_conntrack_helper_register(&amp;foo);
}

static void __exit fini(void)
{
        ip_conntrack_helper_unregister(&amp;foo);
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<H3>NAT helper modules</H3>

<H3>Description</H3>

<P>NAT helper modules do some application specific NAT handling.  Usually
this includes on-the-fly manipulation of data: think about the PORT
command in FTP, where the client tells the server which IP/port to
connect to.  Therefor an FTP helper module must replace the IP/port
after the PORT command in the FTP control connection.</P>

<P>If we are dealing with TCP, things get slightly more complicated.  The
reason is a possible change of the packet size (FTP example: the
length of the string representing an IP/port tuple after the PORT
command has changed).  If we change the packet size, we have a syn/ack
difference between left and right side of the NAT box. (i.e. if we had
extended one packet by 4 octets, we have to add this offset to the TCP
sequence number of each following packet).</P>

<P>Special NAT handling of all related packets is required, too.  Take as
example again FTP, where all incoming packets of the DATA connection
have to be NATed to the IP/port given by the client with the PORT
command on the control connection, rather than going through the
normal table lookup.</P>
<P>
<UL>
<LI>callback for the packet causing the related connection (foo_help)</LI>
<LI>callback for all related packets (foo_nat_expected)</LI>
</UL>
</P>

<H3>Structures and Functions Available</H3>

<P>Your nat helper module's `init()' function calls
`ip_nat_helper_register()' with a pointer to a `struct
ip_nat_helper'.  This struct has the following members:</P>
<P>
<DL>
<DT><B>list</B><DD>
<P>Just again the list header for netfilters internal use.
Initialize this with { NULL, NULL }.</P>

<DT><B>name</B><DD>
<P>A pointer to a string constant with the protocol's name</P>

<DT><B>flags</B><DD>
<P>A set out of zero, one or more of the following flags:
<UL>
<LI>IP_NAT_HELPER_F_ALWAYS : Call the NAT helper for every packet,
not only for packets where conntrack has detected an expectation-cause.</LI>
<LI>IP_NAT_HELPER_F_STANDALONE : Tell the NAT core that this protocol
doesn't have a conntrack helper, only a NAT helper.</LI>
</UL>
</P>

<DT><B>me</B><DD>
<P>A pointer to the module structure of the helper.  Initialize
this using the `THIS_MODULE' macro.</P>

<DT><B>tuple</B><DD>
<P>a `struct ip_conntrack_tuple' describing which packets
our NAT helper is interested in.</P>

<DT><B>mask</B><DD>
<P>a `struct ip_conntrack_tuple', telling netfilter which
bits of <CODE>tuple</CODE> are valid.</P>

<DT><B>help</B><DD>
<P>The help function which is called for each packet
matching tuple+mask.</P>

<DT><B>expect</B><DD>
<P>The expect function which is called for every first
packet of an expected connection.</P>

</DL>
</P>
<P>This is very similar to writing a connection tracking helper.</P>

<H3>Example NAT helper module</H3>

<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#define FOO_PORT        111

static int foo_nat_expected(struct sk_buff **pksb,
                        unsigned int hooknum,
                        struct ip_conntrack *ct,
                        struct ip_nat_info *info)
/* called whenever the first packet of a related connection arrives.
   params:      pksb    packet buffer
                hooknum HOOK the call comes from (POST_ROUTING, PRE_ROUTING)
                ct      information about this (the related) connection
                info    &amp;ct->nat.info
   return value: Verdict (NF_ACCEPT, ...)
{
        /* Change ip/port of the packet to the masqueraded
           values (read from master->tuplehash), to map it the same way,
           call ip_nat_setup_info, return NF_ACCEPT. */

}

static int foo_help(struct ip_conntrack *ct,
                    struct ip_conntrack_expect *exp,
                    struct ip_nat_info *info,
                    enum ip_conntrack_info ctinfo,
                    unsigned int hooknum,
                    struct sk_buff  **pksb)
/* called for every packet where conntrack detected an expectation-cause
   params:      ct      struct ip_conntrack of the master connection
                exp     struct ip_conntrack_expect of the expectation
                        caused by the conntrack helper for this protocol
                info    (STATE: related, new, established, ... )
                hooknum HOOK the call comes from (POST_ROUTING, PRE_ROUTING)
                pksb    packet buffer
*/
{

        /* extract information about future related packets (you can
           share information with the connection tracking's foo_help).
           Exchange address/port with masqueraded values, insert tuple
           about related packets */
}

static struct ip_nat_helper hlpr;

static int __init(void)
{
        int ret;

        memset(&amp;hlpr, 0, sizeof(struct ip_nat_helper));
        hlpr.list = { NULL, NULL };
        hlpr.tuple.dst.protonum = IPPROTO_TCP;
        hlpr.tuple.dst.u.tcp.port = htons(FOO_PORT);
        hlpr.mask.dst.protonum = 0xFFFF;
        hlpr.mask.dst.u.tcp.port = 0xFFFF;
        hlpr.help = foo_help;
        hlpr.expect = foo_nat_expect;

        ret = ip_nat_helper_register(hlpr);

        return ret;
}

static void __exit(void)
{
        ip_nat_helper_unregister(&amp;hlpr);
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss4.5">4.5</A> <A HREF="netfilter-hacking-HOWTO.html#toc4.5">Understanding Netfilter</A>
</H2>

<P>Netfilter is pretty simple, and is described fairly thoroughly in
the previous sections.  However, sometimes it's necessary to go
beyond what the NAT or ip_tables infrastructure offers, or you may
want to replace them entirely.</P>

<P>One important issue for netfilter (well, in the future) is caching.
Each skb has an `nfcache' field: a bitmask of what fields in the
header were examined, and whether the packet was altered or not.  The
idea is that each hook off netfilter OR's in the bits relevant to it,
so that we can later write a cache system which will be clever enough
to realize when packets do not need to be passed through netfilter at
all.</P>

<P>The most important bits are NFC_ALTERED, meaning the packet was
altered (this is already used for IPv4's NF_IP_LOCAL_OUT hook, to
reroute altered packets), and NFC_UNKNOWN, which means caching should
not be done because some property which cannot be expressed was
examined.  If in doubt, simply set the NFC_UNKNOWN flag on the skb's
nfcache field inside your hook.</P>

<H2><A NAME="ss4.6">4.6</A> <A HREF="netfilter-hacking-HOWTO.html#toc4.6">Writing New Netfilter Modules</A>
</H2>

<H3>Plugging Into Netfilter Hooks</H3>

<P> To receive/mangle packets inside the kernel, you can simply write
a module which registers a "netfilter hook".  This is basically an
expression of interest at some given point; the actual points are
protocol-specific, and defined in protocol-specific netfilter headers,
such as "netfilter_ipv4.h".</P>

<P> To register and unregister netfilter hooks, you use the functions
`nf_register_hook' and `nf_unregister_hook'.  These each take a
pointer to a `struct nf_hook_ops', which you populate as follows:</P>
<P>
<DL>
<DT><B>list</B><DD>
<P>Used to sew you into the linked list: set to '{ NULL,
NULL }'</P>

<DT><B>hook</B><DD>
<P>The function which is called when a packet hits this
hook point.  Your function must return NF_ACCEPT, NF_DROP or NF_QUEUE.
If NF_ACCEPT, the next hook attached to that point will be called.  If
NF_DROP, the packet is dropped.  If NF_QUEUE, it's queued.  You
receive a pointer to an skb pointer, so you can entirely replace the
skb if you wish.</P>

<DT><B>flush</B><DD>
<P>Currently unused: designed to pass on packet hits
when the cache is flushed.  May never be implemented: set it to NULL.</P>

<DT><B>pf</B><DD>
<P>The protocol family, eg, `PF_INET' for IPv4.</P>

<DT><B>hooknum</B><DD>
<P>The number of the hook you are interested in, eg
`NF_IP_LOCAL_OUT'.</P>
</DL>
</P>

<H3>Processing Queued Packets</H3>

<P>This interface is currently used by ip_queue; you can register to
handle queued packets for a given protocol.  This has similar semantics
to registering for a hook, except you can block processing the packet,
and you only see packets for which a hook has replied `NF_QUEUE'.</P>

<P>The two functions used to register interest in queued packets are
`nf_register_queue_handler()' and `nf_unregister_queue_handler()'.  The
function you register will be called with the `void *' pointer you
handed it to `nf_register_queue_handler()'.</P>

<P>If no-one is registered to handle a protocol, then returning NF_QUEUE
is equivalent to returning NF_DROP.</P>

<P>Once you have registered interest in queued packets, they begin
queueing.  You can do whatever you want with them, but you must call
`nf_reinject()' when you are finished with them (don't simply
kfree_skb() them).  When you reinject an skb, you hand it the skb, the
`struct nf_info' which your queue handler was given, and a verdict:
NF_DROP causes them to be dropped, NF_ACCEPT causes them to continue
to iterate through the hooks, NF_QUEUE causes them to be queued again,
and NF_REPEAT causes the hook which queued the packet to be consulted
again (beware infinite loops).</P>

<P>You can look inside the `struct nf_info' to get auxiliary
information about the packet, such as the interfaces and hook it was
on.</P>

<H3>Receiving Commands From Userspace</H3>

<P>It is common for netfilter components to want to interact with
userspace.  The method for doing this is by using the setsockopt
mechanism.  Note that each protocol must be modified to call
nf_setsockopt() for setsockopt numbers it doesn't understand (and
nf_getsockopt() for getsockopt numbers), and so far only IPv4, IPv6
and DECnet have been modified.</P>

<P>Using a now-familiar technique, we register a `struct
nf_sockopt_ops' using the nf_register_sockopt() call.  The fields of
this structure are as follows:</P>
<P>
<DL>
<DT><B>list</B><DD>
<P>Used to sew it into the linked list: set to '{ NULL,
NULL }'.</P>

<DT><B>pf</B><DD>
<P>The protocol family you handle, eg. PF_INET.</P>

<DT><B>set_optmin</B><DD>
<P>and</P>
<DT><B>set_optmax</B><DD>
<P>These specify the (exclusive) range of setsockopt numbers handled.
Hence using 0 and 0 means you have no setsockopt numbers.</P>

<DT><B>set</B><DD>
<P>This is the function called when the user calls one of
your setsockopts.  You should check that they have NET_ADMIN
capability within this function.</P>

<DT><B>get_optmin</B><DD>
<P>and</P>
<DT><B>get_optmax</B><DD>
<P>These specify the (exclusive) range of getsockopt numbers handled.
Hence using 0 and 0 means you have no getsockopt numbers.</P>

<DT><B>get</B><DD>
<P>This is the function called when the user calls one of
your getsockopts.  You should check that they have NET_ADMIN
capability within this function.</P>
</DL>
</P>

<P>The final two fields are used internally.</P>

<H2><A NAME="ss4.7">4.7</A> <A HREF="netfilter-hacking-HOWTO.html#toc4.7">Packet Handling in Userspace</A>
</H2>

<P>Using the libipq library and the `ip_queue' module, almost anything
which can be done inside the kernel can now be done in userspace.
This means that, with some speed penalty, you can develop your code
entirely in userspace.  Unless you are trying to filter large
bandwidths, you should find this approach superior to in-kernel packet
mangling.</P>

<P>In the very early days of netfilter, I proved this by porting an
embryonic version of iptables to userspace.  Netfilter opens the doors
for more people to write their own, fairly efficient netmangling
modules, in whatever language they want.</P>

<HR>
<A HREF="netfilter-hacking-HOWTO-5.html">Next</A>
<A HREF="netfilter-hacking-HOWTO-3.html">Previous</A>
<A HREF="netfilter-hacking-HOWTO.html#toc4">Contents</A>
</BODY>
</HTML>
